import { WebAuthnCredentialKeyMetaType } from '@repo/enums';
import { COSEKey } from '@repo/keys';
import {
  CHALLENGE_BASE64URL,
  CHALLENGE_RAW,
  KEY_VAULT_KEY_ID,
  KEY_VAULT_KEY_NAME,
  RP_ID,
  RP_NAME,
  upsertTestingUser,
  USER_DISPLAY_NAME,
  USER_ID,
  USER_ID_RAW,
  USER_NAME,
} from '@repo/test-helpers';
import { bufferToUuid } from '@repo/utils';
import {
  PublicKeyCredentialRequestOptions,
  PublicKeyCredentialCreationOptions,
  PublicKeyCredentialSchema,
} from '@repo/validation';
import {
  verifyAuthenticationResponse,
  verifyRegistrationResponse,
  type AuthenticationResponseJSON,
  type RegistrationResponseJSON,
  type VerifiedRegistrationResponse,
} from '@simplewebauthn/server';
import { afterAll, beforeAll, describe, expect, test } from 'vitest';

import { VirtualAuthenticator } from '../../src/VirtualAuthenticator';
import { credentialSigner } from '../helpers/credentialSigner';
import { COSEPublicKey, keyPair } from '../helpers/key';
import { prisma } from '../helpers/prisma';

const publicKeyCredentialCreationOptions: PublicKeyCredentialCreationOptions = {
  rp: {
    name: RP_NAME,
    id: RP_ID,
  },
  user: {
    id: USER_ID_RAW,
    name: USER_NAME,
    displayName: USER_DISPLAY_NAME,
  },
  challenge: CHALLENGE_RAW,
  pubKeyCredParams: [{ type: 'public-key', alg: -7 }],
  timeout: 60000,
  attestation: 'none',
};

const createPublicKeyCredentialRequestOptions = (
  credentialID: Buffer,
): PublicKeyCredentialRequestOptions => ({
  challenge: CHALLENGE_RAW,
  rpId: RP_ID,
  allowCredentials: [
    {
      id: credentialID,
      type: 'public-key',
    },
  ],
  userVerification: 'required',
});

describe('VirtualAuthenticator', () => {
  let authenticator: VirtualAuthenticator;
  let registrationVerification: VerifiedRegistrationResponse;

  beforeAll(async () => {
    // Initialize the VirtualAuthenticator instance, passing in the Prisma client
    // for database interactions.
    authenticator = new VirtualAuthenticator({ prisma });

    // Ensure the standard testing user exists in the database.
    await upsertTestingUser({ prisma });

    // Simulate the full WebAuthn registration ceremony.
    // This creates a new public key credential (passkey) using the
    // specified options, public key, and key vault metadata.
    const publicKeyCredential = await authenticator.createCredential({
      publicKeyCredentialCreationOptions,
      COSEPublicKey,
      meta: {
        webAuthnCredentialKeyMetaType: WebAuthnCredentialKeyMetaType.KEY_VAULT,
        webAuthnCredentialKeyVaultKeyMeta: {
          keyVaultKeyId: KEY_VAULT_KEY_ID,
          keyVaultKeyName: KEY_VAULT_KEY_NAME,
          hsm: false,
        },
      },
    });

    // Verify the registration response generated by the authenticator.
    // This confirms the credential was created correctly according to
    // WebAuthn standards and our server's expectations (challenge, RP ID, etc.).
    // The result is stored in `registrationVerification` to be used by
    // the authentication tests (`getCredential` describe block).
    registrationVerification = await verifyRegistrationResponse({
      response: PublicKeyCredentialSchema.encode(
        publicKeyCredential,
      ) as RegistrationResponseJSON,
      expectedChallenge: CHALLENGE_BASE64URL,
      expectedOrigin: publicKeyCredentialCreationOptions.rp.id!,
      expectedRPID: publicKeyCredentialCreationOptions.rp.id,
      requireUserVerification: true, // Authenticator does perform UV
      requireUserPresence: false, // Authenticator does NOT perform UP
    });
  });

  afterAll(async () => {
    // Clean up the database after all tests in this suite have finished.
    // This ensures a clean state and prevents test pollution.

    // Remove the credential created during the test.
    await prisma.webAuthnCredential.deleteMany();
    // Remove the key vault metadata.
    await prisma.webAuthnCredentialKeyVaultKeyMeta.deleteMany();
    // Remove the test user.
    await prisma.user.deleteMany();
  });

  /**
   * These tests verify the output of the `beforeAll` block.
   * They confirm that the registration was successful and correct.
   */
  describe('createCredential()', () => {
    test('should be verified successfully', () => {
      expect(registrationVerification.verified).toBe(true);
    });

    test('should initialize the signature counter to 0', () => {
      expect(
        registrationVerification.registrationInfo?.credential.counter,
      ).toBe(0);
    });

    test('should contain the correct public key', () => {
      const jwk = COSEKey.fromBuffer(
        registrationVerification.registrationInfo!.credential.publicKey,
      ).toJwk();

      expect(jwk).toMatchObject(keyPair.publicKey.export({ format: 'jwk' }));
    });

    test('credential ID should be in the database', async () => {
      const credentialID = bufferToUuid(
        Buffer.from(
          registrationVerification.registrationInfo!.credential.id,
          'base64url',
        ),
      );

      const webAuthnCredential = await prisma.webAuthnCredential.findUnique({
        where: {
          id: credentialID,
        },
      });

      expect(webAuthnCredential).toMatchObject({
        id: credentialID,
      });
    });
  });

  /**
   * This block tests the authentication flow.
   * It uses the verified registration from the `beforeAll` setup
   * to request and verify a new assertion.
   */
  describe('getCredential()', () => {
    // Store credential info and the current counter state to
    // be used and updated across sequential auth tests.
    let credentialID: string;
    let credentialPublicKey: Uint8Array<ArrayBuffer>;
    let currentCounter: number;

    /**
     * Helper function to de-duplicate the authentication and verification logic.
     * It uses and updates the `currentCounter` from the describe block's scope.
     */
    const performAndVerifyAuth = async (options: {
      requestOptions: PublicKeyCredentialRequestOptions;
      expectedNewCounter: number;
    }) => {
      const { requestOptions, expectedNewCounter } = options;

      const publicKeyCredential = await authenticator.getCredential({
        publicKeyCredentialRequestOptions: requestOptions,
        credentialSignerFactory: () => credentialSigner,
        meta: {
          user: {
            id: USER_ID,
          },
        },
      });

      const authenticationVerification = await verifyAuthenticationResponse({
        response: PublicKeyCredentialSchema.encode(
          publicKeyCredential,
        ) as AuthenticationResponseJSON,
        expectedChallenge: CHALLENGE_BASE64URL,
        expectedOrigin: RP_ID,
        expectedRPID: RP_ID,
        credential: {
          id: credentialID,
          publicKey: credentialPublicKey,
          counter: currentCounter, // Pass the last known counter
        },
        requireUserVerification: true,
      });

      // The most important check: confirm that the authentication was successful.
      expect(authenticationVerification.verified).toBe(true);

      // A critical security check: ensure the signature counter has incremented.
      expect(authenticationVerification.authenticationInfo.newCounter).toBe(
        expectedNewCounter,
      );

      // Update the counter for the next sequential test
      currentCounter = authenticationVerification.authenticationInfo.newCounter;
    };

    // Initialize the shared auth variables from the registration data
    beforeAll(() => {
      const { id, publicKey, counter } =
        registrationVerification.registrationInfo!.credential;

      credentialID = id;
      credentialPublicKey = publicKey;
      currentCounter = counter; // Should be 0
    });

    test('should produce a verifiable assertion', async () => {
      const requestOptions = createPublicKeyCredentialRequestOptions(
        Buffer.from(credentialID, 'base64url'),
      );

      await performAndVerifyAuth({
        requestOptions,
        expectedNewCounter: 1,
      });
    });

    test('should produce a verifiable assertion without allowCredentials', async () => {
      const baseRequestOptions = createPublicKeyCredentialRequestOptions(
        Buffer.from(credentialID, 'base64url'),
      );

      await performAndVerifyAuth({
        requestOptions: {
          ...baseRequestOptions,
          allowCredentials: undefined,
        },
        expectedNewCounter: 2, // Increments from the previous test
      });
    });

    test('should produce a verifiable assertion with redundant allowCredentials', async () => {
      const baseRequestOptions = createPublicKeyCredentialRequestOptions(
        Buffer.from(credentialID, 'base64url'),
      );

      await performAndVerifyAuth({
        requestOptions: {
          ...baseRequestOptions,
          allowCredentials: [
            { id: Buffer.from('WRONG_CREDENTIAL_ID'), type: 'public-key' },
            ...(baseRequestOptions.allowCredentials ?? []),
          ],
        },
        expectedNewCounter: 3, // Increments from the previous test
      });
    });

    test('should fail with different RP ID', async () => {
      const { id: credentialID } =
        registrationVerification.registrationInfo!.credential;

      const publicKeyCredentialRequestOptions =
        createPublicKeyCredentialRequestOptions(
          Buffer.from(credentialID, 'base64url'),
        );

      await expect(() =>
        authenticator.getCredential({
          publicKeyCredentialRequestOptions: {
            ...publicKeyCredentialRequestOptions,
            rpId: 'WRONG_RP_ID',
          },
          credentialSignerFactory: () => credentialSigner,
          meta: {
            user: {
              id: USER_ID,
            },
          },
        }),
      ).to.rejects.toThrowError();
    });

    test('should fail with different user ID', async () => {
      const { id: credentialID } =
        registrationVerification.registrationInfo!.credential;

      const publicKeyCredentialRequestOptions =
        createPublicKeyCredentialRequestOptions(
          Buffer.from(credentialID, 'base64url'),
        );

      await expect(() =>
        authenticator.getCredential({
          publicKeyCredentialRequestOptions,
          credentialSignerFactory: () => credentialSigner,
          meta: {
            user: {
              id: 'WRONG_USER_ID',
            },
          },
        }),
      ).to.rejects.toThrowError();
    });

    test('should fail with wrong allowCredentials', async () => {
      const { id: credentialID } =
        registrationVerification.registrationInfo!.credential;

      const publicKeyCredentialRequestOptions =
        createPublicKeyCredentialRequestOptions(
          Buffer.from(credentialID, 'base64url'),
        );

      await expect(() =>
        authenticator.getCredential({
          publicKeyCredentialRequestOptions: {
            ...publicKeyCredentialRequestOptions,
            allowCredentials: [
              { id: Buffer.from('WRONG_CREDENTIAL_ID'), type: 'public-key' },
            ],
          },
          credentialSignerFactory: () => credentialSigner,
          meta: {
            user: {
              id: 'WRONG_USER_ID',
            },
          },
        }),
      ).to.rejects.toThrowError();
    });
  });
});

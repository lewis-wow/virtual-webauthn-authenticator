import { upsertTestingUser, USER_ID } from '../../../../auth/__tests__/helpers';
import { setDeep } from '../../../../core/__tests__/helpers';
import {
  KEY_VAULT_KEY_ID,
  KEY_VAULT_KEY_NAME,
} from '../../../../key-vault/__tests__/helpers';

import { UUIDMapper } from '@repo/core/mappers';
import { COSEKeyAlgorithm } from '@repo/keys/enums';
import { COSEKeyMapper } from '@repo/keys/mappers';
import { PrismaClient } from '@repo/prisma';
import {
  VerifiedRegistrationResponse,
  verifyRegistrationResponse,
  type RegistrationResponseJSON,
} from '@simplewebauthn/server';
import { afterAll, beforeAll, describe, expect, test } from 'vitest';

import { PublicKeyCredentialDtoSchema } from '../../../../contract/src/dto/credentials/components/PublicKeyCredentialDtoSchema';
import { VirtualAuthenticator } from '../../../src/VirtualAuthenticator';
import { Attestation } from '../../../src/enums/Attestation';
import { AuthenticatorAttachment } from '../../../src/enums/AuthenticatorAttachment';
import { PublicKeyCredentialType } from '../../../src/enums/PublicKeyCredentialType';
import { ResidentKeyRequirement } from '../../../src/enums/ResidentKeyRequirement';
import { UserVerificationRequirement } from '../../../src/enums/UserVerificationRequirement';
import { AttestationNotSupported } from '../../../src/exceptions/AttestationNotSupported';
import { NoSupportedPubKeyCredParamFound } from '../../../src/exceptions/NoSupportedPubKeyCredParamWasFound';
import { PrismaWebAuthnRepository } from '../../../src/repositories/PrismaWebAuthnRepository';
import type { PublicKeyCredentialCreationOptions } from '../../../src/zod-validation/PublicKeyCredentialCreationOptionsSchema';
import { MockKeyProvider } from '../../helpers/MockKeyProvider';
import {
  CHALLENGE_BASE64URL,
  PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
  RP_ID,
  RP_ORIGIN,
} from '../../helpers/consts';

const prisma = new PrismaClient();

const createCredentialAndVerifyRegistrationResponse = async (opts: {
  authenticator: VirtualAuthenticator;
  publicKeyCredentialCreationOptions: PublicKeyCredentialCreationOptions;
}) => {
  const { authenticator, publicKeyCredentialCreationOptions } = opts;

  // Simulate the full WebAuthn registration ceremony.
  // This creates a new public key credential (passkey) using the
  // specified options, public key, and key vault metadata.
  const publicKeyCredential = await authenticator.createCredential({
    publicKeyCredentialCreationOptions,
    meta: {
      userId: USER_ID,
      origin: RP_ORIGIN,
    },
    context: {
      apiKeyId: null,
    },
  });

  // Verify the registration response generated by the authenticator.
  // This confirms the credential was created correctly according to
  // WebAuthn standards and our server's expectations (challenge, RP ID, etc.).
  const registrationVerification = await verifyRegistrationResponse({
    response: PublicKeyCredentialDtoSchema.encode(
      publicKeyCredential,
    ) as RegistrationResponseJSON,
    expectedChallenge: CHALLENGE_BASE64URL,
    expectedOrigin: RP_ORIGIN,
    expectedRPID: RP_ID,
    requireUserVerification: true, // Authenticator does perform UV
    requireUserPresence: false, // Authenticator does NOT perform UP
  });

  const webAuthnCredentialId = UUIDMapper.bytesToUUID(
    publicKeyCredential.rawId,
  );

  return {
    publicKeyCredential,
    registrationVerification,
    webAuthnCredentialId,
  };
};

const cleanup = async () => {
  await prisma.$transaction([
    prisma.user.deleteMany(),
    prisma.webAuthnCredential.deleteMany(),
    prisma.webAuthnCredentialKeyVaultKeyMeta.deleteMany(),
  ]);
};

describe('VirtualAuthenticator.createCredential()', () => {
  const keyProvider = new MockKeyProvider();
  const webAuthnCredentialRepository = new PrismaWebAuthnRepository({
    prisma,
  });
  const authenticator = new VirtualAuthenticator({
    webAuthnRepository: webAuthnCredentialRepository,
    keyProvider,
  });

  describe('PublicKeyCredentialCreationOptions.attestation', () => {
    describe.each([
      {
        attestation: undefined,
      } satisfies Partial<PublicKeyCredentialCreationOptions>,
      {
        attestation: Attestation.NONE,
      } satisfies Partial<PublicKeyCredentialCreationOptions>,
      {
        attestation: Attestation.DIRECT,
      } satisfies Partial<PublicKeyCredentialCreationOptions>,
    ])('With attestation $attestation', ({ attestation }) => {
      let registrationVerification: VerifiedRegistrationResponse;
      let webAuthnCredentialId: string;

      const publicKeyCredentialCreationOptions = {
        ...PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
        attestation,
      } satisfies PublicKeyCredentialCreationOptions;

      beforeAll(async () => {
        await cleanup();
        await upsertTestingUser({ prisma });

        ({ registrationVerification, webAuthnCredentialId } =
          await createCredentialAndVerifyRegistrationResponse({
            authenticator,
            publicKeyCredentialCreationOptions,
          }));
      });

      afterAll(async () => {
        await cleanup();
      });

      test('Should return a verified registration', () => {
        expect(registrationVerification.verified).toBe(true);
      });

      test('Should have a counter of 0', () => {
        expect(
          registrationVerification.registrationInfo?.credential.counter,
        ).toBe(0);
      });

      test('Should have the correct public key', () => {
        const jwk = COSEKeyMapper.COSEKeyToJwk(
          COSEKeyMapper.bytesToCOSEKey(
            registrationVerification.registrationInfo!.credential.publicKey,
          ),
        );

        expect(jwk).toMatchObject(
          keyProvider
            .getKeyPairStore()
            [webAuthnCredentialId].publicKey.export({ format: 'jwk' }),
        );
      });

      test('Should save the WebAuthnCredential to the database', async () => {
        const webAuthnCredential = await prisma.webAuthnCredential.findUnique({
          where: {
            id: webAuthnCredentialId,
          },
        });

        expect(webAuthnCredential).toMatchObject({
          id: webAuthnCredentialId,
          userId: USER_ID,
        });
      });

      test('Should save the KeyVaultKeyMeta to the database', async () => {
        const keyMeta =
          await prisma.webAuthnCredentialKeyVaultKeyMeta.findFirst({
            where: {
              webAuthnCredentialId: webAuthnCredentialId,
            },
          });

        expect(keyMeta).toMatchObject({
          webAuthnCredentialId: webAuthnCredentialId,
          keyVaultKeyId: KEY_VAULT_KEY_ID,
          keyVaultKeyName: KEY_VAULT_KEY_NAME,
          hsm: false,
        });
      });
    });

    test.each([
      {
        attestation: Attestation.ENTERPRISE,
      } satisfies Partial<PublicKeyCredentialCreationOptions>,
      {
        attestation: Attestation.INDIRECT,
      } satisfies Partial<PublicKeyCredentialCreationOptions>,
    ])(
      `Should throw ${AttestationNotSupported.name} with attestation $attestation`,
      async ({ attestation }) => {
        await expect(async () =>
          createCredentialAndVerifyRegistrationResponse({
            authenticator,
            publicKeyCredentialCreationOptions: setDeep(
              PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
              'attestation',
              () => attestation,
            ),
          }),
        ).rejects.toThrowError(
          new AttestationNotSupported({ data: { attestation } }),
        );
      },
    );

    test('Shold throw type mismatch when attestation is not in enum', async () => {
      const publicKeyCredentialCreationOptions = {
        ...PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
        attestation: 'WRONG_ATTESTATION',
      };

      await expect(async () =>
        createCredentialAndVerifyRegistrationResponse({
          authenticator,
          publicKeyCredentialCreationOptions:
            publicKeyCredentialCreationOptions as PublicKeyCredentialCreationOptions,
        }),
      ).rejects.toThrowError();
    });
  });

  describe('PublicKeyCredentialCreationOptions.pubKeyCredParams', () => {
    test('Should throw type mismatch when pubKeyCredParams is empty', async () => {
      const publicKeyCredentialCreationOptions = {
        ...PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
        pubKeyCredParams: [],
      };

      await expect(async () =>
        createCredentialAndVerifyRegistrationResponse({
          authenticator,
          publicKeyCredentialCreationOptions,
        }),
      ).rejects.toThrowError();
    });

    test.each([
      {
        pubKeyCredParams: [{ type: 'WRONG_TYPE', alg: COSEKeyAlgorithm.ES256 }],
      } satisfies Partial<PublicKeyCredentialCreationOptions>,
      {
        pubKeyCredParams: [
          {
            type: PublicKeyCredentialType.PUBLIC_KEY,
            alg: -8,
          },
        ],
      } satisfies Partial<PublicKeyCredentialCreationOptions>,
      {
        pubKeyCredParams: [
          {
            type: PublicKeyCredentialType.PUBLIC_KEY,
            alg: -8,
          },
          {
            type: 'WRONG_TYPE',
            alg: COSEKeyAlgorithm.ES256,
          },
        ],
      } satisfies Partial<PublicKeyCredentialCreationOptions>,
    ])(
      'Should throw with any supported pubKeyCredParams',
      async ({ pubKeyCredParams }) => {
        const publicKeyCredentialCreationOptions = {
          ...PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
          pubKeyCredParams,
          attestation: undefined,
        };

        await expect(async () =>
          createCredentialAndVerifyRegistrationResponse({
            authenticator,
            publicKeyCredentialCreationOptions,
          }),
        ).rejects.toThrowError(new NoSupportedPubKeyCredParamFound());
      },
    );
  });

  describe('meta.userId', () => {
    test('Should throw type mismatch when userId is invalid', async () => {
      await expect(async () =>
        authenticator.createCredential({
          publicKeyCredentialCreationOptions:
            PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
          meta: {
            userId: 'INVALID_USER_ID',
            origin: RP_ORIGIN,
          },
          context: {
            apiKeyId: null,
          },
        }),
      ).to.rejects.toThrowError();
    });
  });

  describe('PublicKeyCredentialCreationOptions.authenticatorSelection', () => {
    describe('authenticatorSelection.userVerification', () => {
      describe.each([
        {
          userVerification: undefined,
        },
        {
          userVerification: UserVerificationRequirement.PREFERRED,
        },
        {
          userVerification: UserVerificationRequirement.REQUIRED,
        },
        {
          userVerification: UserVerificationRequirement.DISCOURAGED,
        },
      ])('With userVerification $userVerification', ({ userVerification }) => {
        let registrationVerification: VerifiedRegistrationResponse;
        let webAuthnCredentialId: string;

        const publicKeyCredentialCreationOptions = {
          ...PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
          attestation: Attestation.NONE,
          authenticatorSelection: {
            userVerification,
          },
        } satisfies PublicKeyCredentialCreationOptions;

        beforeAll(async () => {
          await cleanup();
          await upsertTestingUser({ prisma });

          ({ registrationVerification, webAuthnCredentialId } =
            await createCredentialAndVerifyRegistrationResponse({
              authenticator,
              publicKeyCredentialCreationOptions,
            }));
        });

        afterAll(async () => {
          await cleanup();
        });

        test('Should return a verified registration', () => {
          expect(registrationVerification.verified).toBe(true);
        });

        test('Should save the WebAuthnCredential to the database', async () => {
          const webAuthnCredential = await prisma.webAuthnCredential.findUnique(
            {
              where: {
                id: webAuthnCredentialId,
              },
            },
          );

          expect(webAuthnCredential).toMatchObject({
            id: webAuthnCredentialId,
            userId: USER_ID,
          });
        });
      });

      test('Should throw type mismatch when userVerification is not in enum', async () => {
        const publicKeyCredentialCreationOptions = {
          ...PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
          authenticatorSelection: {
            userVerification: 'INVALID_USER_VERIFICATION',
          },
        };

        await expect(async () =>
          createCredentialAndVerifyRegistrationResponse({
            authenticator,
            publicKeyCredentialCreationOptions:
              publicKeyCredentialCreationOptions as PublicKeyCredentialCreationOptions,
          }),
        ).rejects.toThrowError();
      });
    });

    describe('authenticatorSelection.authenticatorAttachment', () => {
      describe.each([
        {
          authenticatorAttachment: undefined,
        },
        {
          authenticatorAttachment: AuthenticatorAttachment.PLATFORM,
        },
        {
          authenticatorAttachment: AuthenticatorAttachment.CROSS_PLATFORM,
        },
      ])(
        'With authenticatorAttachment $authenticatorAttachment',
        ({ authenticatorAttachment }) => {
          let registrationVerification: VerifiedRegistrationResponse;
          let webAuthnCredentialId: string;

          const publicKeyCredentialCreationOptions = {
            ...PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
            attestation: Attestation.NONE,
            authenticatorSelection: {
              authenticatorAttachment,
            },
          } satisfies PublicKeyCredentialCreationOptions;

          beforeAll(async () => {
            await cleanup();
            await upsertTestingUser({ prisma });

            ({ registrationVerification, webAuthnCredentialId } =
              await createCredentialAndVerifyRegistrationResponse({
                authenticator,
                publicKeyCredentialCreationOptions,
              }));
          });

          afterAll(async () => {
            await cleanup();
          });

          test('Should return a verified registration', () => {
            expect(registrationVerification.verified).toBe(true);
          });

          test('Should save the WebAuthnCredential to the database', async () => {
            const webAuthnCredential =
              await prisma.webAuthnCredential.findUnique({
                where: {
                  id: webAuthnCredentialId,
                },
              });

            expect(webAuthnCredential).toMatchObject({
              id: webAuthnCredentialId,
              userId: USER_ID,
            });
          });
        },
      );

      test('Should throw type mismatch when authenticatorAttachment is not in enum', async () => {
        const publicKeyCredentialCreationOptions = {
          ...PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
          authenticatorSelection: {
            authenticatorAttachment: 'INVALID_ATTACHMENT',
          },
        };

        await expect(async () =>
          createCredentialAndVerifyRegistrationResponse({
            authenticator,
            publicKeyCredentialCreationOptions:
              publicKeyCredentialCreationOptions as PublicKeyCredentialCreationOptions,
          }),
        ).rejects.toThrowError();
      });
    });

    describe('authenticatorSelection.residentKey', () => {
      describe.each([
        {
          residentKey: undefined,
        },
        {
          residentKey: ResidentKeyRequirement.DISCOURAGED,
        },
        {
          residentKey: ResidentKeyRequirement.PREFERRED,
        },
        {
          residentKey: ResidentKeyRequirement.REQUIRED,
        },
      ])('With residentKey $residentKey', ({ residentKey }) => {
        let registrationVerification: VerifiedRegistrationResponse;
        let webAuthnCredentialId: string;

        const publicKeyCredentialCreationOptions = {
          ...PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
          attestation: Attestation.NONE,
          authenticatorSelection: {
            residentKey,
          },
        } satisfies PublicKeyCredentialCreationOptions;

        beforeAll(async () => {
          await cleanup();
          await upsertTestingUser({ prisma });

          ({ registrationVerification, webAuthnCredentialId } =
            await createCredentialAndVerifyRegistrationResponse({
              authenticator,
              publicKeyCredentialCreationOptions,
            }));
        });

        afterAll(async () => {
          await cleanup();
        });

        test('Should return a verified registration', () => {
          expect(registrationVerification.verified).toBe(true);
        });

        test('Should save the WebAuthnCredential to the database', async () => {
          const webAuthnCredential = await prisma.webAuthnCredential.findUnique(
            {
              where: {
                id: webAuthnCredentialId,
              },
            },
          );

          expect(webAuthnCredential).toMatchObject({
            id: webAuthnCredentialId,
            userId: USER_ID,
          });
        });
      });

      test('Should throw type mismatch when residentKey is not in enum', async () => {
        const publicKeyCredentialCreationOptions = {
          ...PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
          authenticatorSelection: {
            residentKey: 'INVALID_RESIDENT_KEY',
          },
        };

        await expect(async () =>
          createCredentialAndVerifyRegistrationResponse({
            authenticator,
            publicKeyCredentialCreationOptions:
              publicKeyCredentialCreationOptions as PublicKeyCredentialCreationOptions,
          }),
        ).rejects.toThrowError();
      });
    });

    describe('authenticatorSelection.requireResidentKey (deprecated)', () => {
      describe.each([
        {
          requireResidentKey: undefined,
        },
        {
          requireResidentKey: true,
        },
        {
          requireResidentKey: false,
        },
      ])(
        'With requireResidentKey $requireResidentKey',
        ({ requireResidentKey }) => {
          let registrationVerification: VerifiedRegistrationResponse;
          let webAuthnCredentialId: string;

          const publicKeyCredentialCreationOptions = {
            ...PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
            attestation: Attestation.NONE,
            authenticatorSelection: {
              requireResidentKey,
            },
          } satisfies PublicKeyCredentialCreationOptions;

          beforeAll(async () => {
            await cleanup();
            await upsertTestingUser({ prisma });

            ({ registrationVerification, webAuthnCredentialId } =
              await createCredentialAndVerifyRegistrationResponse({
                authenticator,
                publicKeyCredentialCreationOptions,
              }));
          });

          afterAll(async () => {
            await cleanup();
          });

          test('Should return a verified registration', () => {
            expect(registrationVerification.verified).toBe(true);
          });

          test('Should save the WebAuthnCredential to the database', async () => {
            const webAuthnCredential =
              await prisma.webAuthnCredential.findUnique({
                where: {
                  id: webAuthnCredentialId,
                },
              });

            expect(webAuthnCredential).toMatchObject({
              id: webAuthnCredentialId,
              userId: USER_ID,
            });
          });
        },
      );

      test('Should throw type mismatch when requireResidentKey is not a boolean', async () => {
        const publicKeyCredentialCreationOptions = {
          ...PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
          authenticatorSelection: {
            requireResidentKey: 'INVALID_BOOLEAN',
          },
        };

        await expect(async () =>
          createCredentialAndVerifyRegistrationResponse({
            authenticator,
            publicKeyCredentialCreationOptions:
              publicKeyCredentialCreationOptions as unknown as PublicKeyCredentialCreationOptions,
          }),
        ).rejects.toThrowError();
      });
    });

    describe('Combined authenticatorSelection options', () => {
      test('Should work with all authenticatorSelection options combined', async () => {
        await cleanup();
        await upsertTestingUser({ prisma });

        const publicKeyCredentialCreationOptions = {
          ...PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
          attestation: Attestation.NONE,
          authenticatorSelection: {
            authenticatorAttachment: AuthenticatorAttachment.CROSS_PLATFORM,
            residentKey: ResidentKeyRequirement.PREFERRED,
            userVerification: UserVerificationRequirement.REQUIRED,
          },
        } satisfies PublicKeyCredentialCreationOptions;

        const { registrationVerification, webAuthnCredentialId } =
          await createCredentialAndVerifyRegistrationResponse({
            authenticator,
            publicKeyCredentialCreationOptions,
          });

        expect(registrationVerification.verified).toBe(true);

        const webAuthnCredential = await prisma.webAuthnCredential.findUnique({
          where: {
            id: webAuthnCredentialId,
          },
        });

        expect(webAuthnCredential).toMatchObject({
          id: webAuthnCredentialId,
          userId: USER_ID,
        });

        await cleanup();
      });
    });
  });

  describe('PublicKeyCredentialCreationOptions.pubKeyCredParams - Multiple Algorithms', () => {
    describe.each([
      {
        name: 'ES256 only',
        pubKeyCredParams: [
          {
            type: PublicKeyCredentialType.PUBLIC_KEY,
            alg: COSEKeyAlgorithm.ES256,
          },
        ],
      },
      {
        name: 'RS256 only',
        pubKeyCredParams: [
          {
            type: PublicKeyCredentialType.PUBLIC_KEY,
            alg: COSEKeyAlgorithm.RS256,
          },
        ],
      },
      {
        name: 'ES256 and RS256',
        pubKeyCredParams: [
          {
            type: PublicKeyCredentialType.PUBLIC_KEY,
            alg: COSEKeyAlgorithm.ES256,
          },
          {
            type: PublicKeyCredentialType.PUBLIC_KEY,
            alg: COSEKeyAlgorithm.RS256,
          },
        ],
      },
      {
        name: 'All ES algorithms',
        pubKeyCredParams: [
          {
            type: PublicKeyCredentialType.PUBLIC_KEY,
            alg: COSEKeyAlgorithm.ES256,
          },
          {
            type: PublicKeyCredentialType.PUBLIC_KEY,
            alg: COSEKeyAlgorithm.ES384,
          },
          {
            type: PublicKeyCredentialType.PUBLIC_KEY,
            alg: COSEKeyAlgorithm.ES512,
          },
        ],
      },
      {
        name: 'All RS algorithms',
        pubKeyCredParams: [
          {
            type: PublicKeyCredentialType.PUBLIC_KEY,
            alg: COSEKeyAlgorithm.RS256,
          },
          {
            type: PublicKeyCredentialType.PUBLIC_KEY,
            alg: COSEKeyAlgorithm.RS384,
          },
          {
            type: PublicKeyCredentialType.PUBLIC_KEY,
            alg: COSEKeyAlgorithm.RS512,
          },
        ],
      },
      {
        name: 'All PS algorithms',
        pubKeyCredParams: [
          {
            type: PublicKeyCredentialType.PUBLIC_KEY,
            alg: COSEKeyAlgorithm.PS256,
          },
          {
            type: PublicKeyCredentialType.PUBLIC_KEY,
            alg: COSEKeyAlgorithm.PS384,
          },
          {
            type: PublicKeyCredentialType.PUBLIC_KEY,
            alg: COSEKeyAlgorithm.PS512,
          },
        ],
      },
    ])('With $name', ({ pubKeyCredParams }) => {
      let registrationVerification: VerifiedRegistrationResponse;
      let webAuthnCredentialId: string;

      const publicKeyCredentialCreationOptions = {
        ...PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
        attestation: Attestation.NONE,
        pubKeyCredParams,
      } satisfies PublicKeyCredentialCreationOptions;

      beforeAll(async () => {
        await cleanup();
        await upsertTestingUser({ prisma });

        ({ registrationVerification, webAuthnCredentialId } =
          await createCredentialAndVerifyRegistrationResponse({
            authenticator,
            publicKeyCredentialCreationOptions,
          }));
      });

      afterAll(async () => {
        await cleanup();
      });

      test('Should return a verified registration', () => {
        expect(registrationVerification.verified).toBe(true);
      });

      test('Should save the WebAuthnCredential to the database', async () => {
        const webAuthnCredential = await prisma.webAuthnCredential.findUnique({
          where: {
            id: webAuthnCredentialId,
          },
        });

        expect(webAuthnCredential).toMatchObject({
          id: webAuthnCredentialId,
          userId: USER_ID,
        });
      });

      test('Should have the correct public key', () => {
        const jwk = COSEKeyMapper.COSEKeyToJwk(
          COSEKeyMapper.bytesToCOSEKey(
            registrationVerification.registrationInfo!.credential.publicKey,
          ),
        );

        expect(jwk).toMatchObject(
          keyProvider
            .getKeyPairStore()
            [webAuthnCredentialId].publicKey.export({ format: 'jwk' }),
        );
      });
    });
  });

  describe('PublicKeyCredentialCreationOptions.timeout', () => {
    test.each([
      { timeout: undefined },
      { timeout: 30000 },
      { timeout: 60000 },
      { timeout: 120000 },
      { timeout: 300000 },
    ])('Should work with timeout $timeout', async ({ timeout }) => {
      await cleanup();
      await upsertTestingUser({ prisma });

      const publicKeyCredentialCreationOptions = {
        ...PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
        attestation: Attestation.NONE,
        timeout,
      } satisfies PublicKeyCredentialCreationOptions;

      const { registrationVerification } =
        await createCredentialAndVerifyRegistrationResponse({
          authenticator,
          publicKeyCredentialCreationOptions,
        });

      expect(registrationVerification.verified).toBe(true);

      await cleanup();
    });

    test('Should throw type mismatch when timeout is not a number', async () => {
      const publicKeyCredentialCreationOptions = {
        ...PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
        timeout: 'INVALID_TIMEOUT',
      };

      await expect(async () =>
        createCredentialAndVerifyRegistrationResponse({
          authenticator,
          publicKeyCredentialCreationOptions:
            publicKeyCredentialCreationOptions as unknown as PublicKeyCredentialCreationOptions,
        }),
      ).rejects.toThrowError();
    });
  });

  describe('PublicKeyCredentialCreationOptions.excludeCredentials', () => {
    test('Should work with empty excludeCredentials array', async () => {
      await cleanup();
      await upsertTestingUser({ prisma });

      const publicKeyCredentialCreationOptions = {
        ...PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
        attestation: Attestation.NONE,
        excludeCredentials: [],
      } satisfies PublicKeyCredentialCreationOptions;

      const { registrationVerification } =
        await createCredentialAndVerifyRegistrationResponse({
          authenticator,
          publicKeyCredentialCreationOptions,
        });

      expect(registrationVerification.verified).toBe(true);

      await cleanup();
    });

    test('Should work with undefined excludeCredentials', async () => {
      await cleanup();
      await upsertTestingUser({ prisma });

      const publicKeyCredentialCreationOptions = {
        ...PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
        attestation: Attestation.NONE,
        excludeCredentials: undefined,
      } satisfies PublicKeyCredentialCreationOptions;

      const { registrationVerification } =
        await createCredentialAndVerifyRegistrationResponse({
          authenticator,
          publicKeyCredentialCreationOptions,
        });

      expect(registrationVerification.verified).toBe(true);

      await cleanup();
    });
  });
});

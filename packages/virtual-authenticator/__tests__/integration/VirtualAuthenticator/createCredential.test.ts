import {
  Attestation,
  COSEKeyAlgorithm,
  PublicKeyCredentialType,
  WebAuthnCredentialKeyMetaType,
} from '@repo/enums';
import { COSEKey } from '@repo/keys';
import { PrismaClient } from '@repo/prisma';
import {
  CHALLENGE_BASE64URL,
  KEY_VAULT_KEY_ID,
  KEY_VAULT_KEY_NAME,
  PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
  RP_ID,
  RP_ORIGIN,
  upsertTestingUser,
  USER_ID,
  setDeep,
} from '@repo/test-helpers';
import { bytesToUuid } from '@repo/utils';
import {
  PublicKeyCredentialDtoSchema,
  type PublicKeyCredentialCreationOptions,
} from '@repo/validation';
import {
  VerifiedRegistrationResponse,
  verifyRegistrationResponse,
  type RegistrationResponseJSON,
} from '@simplewebauthn/server';
import { afterAll, beforeAll, describe, expect, test } from 'vitest';

import { VirtualAuthenticator } from '../../../src/VirtualAuthenticator';
import { AttestationNotSupported } from '../../../src/exceptions/AttestationNotSupported';
import { NoSupportedPubKeyCredParamFound } from '../../../src/exceptions/NoSupportedPubKeyCredParamWasFound';
import { credentialSigner } from '../../helpers/credentialSigner';
import { COSEPublicKey, keyPair } from '../../helpers/key';

const prisma = new PrismaClient();

const createCredentialAndVerifyRegistrationResponse = async (opts: {
  authenticator: VirtualAuthenticator;
  publicKeyCredentialCreationOptions: PublicKeyCredentialCreationOptions;
}) => {
  const { authenticator, publicKeyCredentialCreationOptions } = opts;

  // Simulate the full WebAuthn registration ceremony.
  // This creates a new public key credential (passkey) using the
  // specified options, public key, and key vault metadata.
  const publicKeyCredential = await authenticator.createCredential({
    publicKeyCredentialCreationOptions,
    generateKeyPair: async () => ({
      COSEPublicKey: COSEPublicKey.toBuffer(),
      webAuthnCredentialKeyMetaType: WebAuthnCredentialKeyMetaType.KEY_VAULT,
      webAuthnCredentialKeyVaultKeyMeta: {
        keyVaultKeyId: KEY_VAULT_KEY_ID,
        keyVaultKeyName: KEY_VAULT_KEY_NAME,
        hsm: false,
      },
    }),
    signatureFactory: ({ data }) => credentialSigner.sign(data),
    meta: {
      userId: USER_ID,
      origin: RP_ORIGIN,
    },
  });

  const publicKeyCredentialJsonEncoded =
    PublicKeyCredentialDtoSchema.encode(publicKeyCredential);

  // Verify the registration response generated by the authenticator.
  // This confirms the credential was created correctly according to
  // WebAuthn standards and our server's expectations (challenge, RP ID, etc.).
  const registrationVerification = await verifyRegistrationResponse({
    response: publicKeyCredentialJsonEncoded as RegistrationResponseJSON,
    expectedChallenge: CHALLENGE_BASE64URL,
    expectedOrigin: RP_ORIGIN,
    expectedRPID: RP_ID,
    requireUserVerification: true, // Authenticator does perform UV
    requireUserPresence: false, // Authenticator does NOT perform UP
  });

  const webAuthnCredentialId = bytesToUuid(publicKeyCredential.rawId);

  return {
    publicKeyCredential,
    registrationVerification,
    webAuthnCredentialId,
  };
};

const cleanup = async () => {
  await prisma.$transaction([
    prisma.user.deleteMany(),
    prisma.webAuthnCredential.deleteMany(),
    prisma.webAuthnCredentialKeyVaultKeyMeta.deleteMany(),
  ]);
};

describe('VirtualAuthenticator.createCredential()', () => {
  const authenticator = new VirtualAuthenticator({ prisma });

  describe('PublicKeyCredentialCreationOptions.attestation', () => {
    describe.each([
      {
        attestation: undefined,
      } satisfies Partial<PublicKeyCredentialCreationOptions>,
      {
        attestation: Attestation.NONE,
      } satisfies Partial<PublicKeyCredentialCreationOptions>,
      {
        attestation: Attestation.DIRECT,
      } satisfies Partial<PublicKeyCredentialCreationOptions>,
    ])('With attestation $attestation', ({ attestation }) => {
      let registrationVerification: VerifiedRegistrationResponse;
      let webAuthnCredentialId: string;

      const publicKeyCredentialCreationOptions = {
        ...PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
        attestation,
      };

      beforeAll(async () => {
        await cleanup();
        await upsertTestingUser({ prisma });

        ({ registrationVerification, webAuthnCredentialId } =
          await createCredentialAndVerifyRegistrationResponse({
            authenticator,
            publicKeyCredentialCreationOptions,
          }));
      });

      afterAll(async () => {
        await cleanup();
      });

      test('Should return a verified registration', () => {
        expect(registrationVerification.verified).toBe(true);
      });

      test('Should have a counter of 0', () => {
        expect(
          registrationVerification.registrationInfo?.credential.counter,
        ).toBe(0);
      });

      test('Should have the correct public key', () => {
        const jwk = COSEKey.fromBuffer(
          registrationVerification.registrationInfo!.credential.publicKey,
        ).toJwk();
        expect(jwk).toMatchObject(keyPair.publicKey.export({ format: 'jwk' }));
      });

      test('Should save the WebAuthnCredential to the database', async () => {
        const webAuthnCredential = await prisma.webAuthnCredential.findUnique({
          where: {
            id: webAuthnCredentialId,
          },
        });

        expect(webAuthnCredential).not.toBeNull();
        expect(webAuthnCredential).toMatchObject({
          id: webAuthnCredentialId,
          userId: USER_ID,
        });
      });

      test('Should save the KeyVaultKeyMeta to the database', async () => {
        const keyMeta =
          await prisma.webAuthnCredentialKeyVaultKeyMeta.findFirst({
            where: {
              webAuthnCredentialId: webAuthnCredentialId,
            },
          });

        expect(keyMeta).not.toBeNull();
        expect(keyMeta).toMatchObject({
          webAuthnCredentialId: webAuthnCredentialId,
          keyVaultKeyId: KEY_VAULT_KEY_ID,
          keyVaultKeyName: KEY_VAULT_KEY_NAME,
          hsm: false,
        });
      });
    });

    test.each([
      {
        attestation: Attestation.ENTERPRISE,
      } satisfies Partial<PublicKeyCredentialCreationOptions>,
      {
        attestation: Attestation.INDIRECT,
      } satisfies Partial<PublicKeyCredentialCreationOptions>,
    ])(
      `Should throw ${AttestationNotSupported.name} with attestation $attestation`,
      async ({ attestation }) => {
        await expect(async () =>
          createCredentialAndVerifyRegistrationResponse({
            authenticator,
            publicKeyCredentialCreationOptions: setDeep(
              PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
              'attestation',
              () => attestation,
            ),
          }),
        ).rejects.toThrowError(new AttestationNotSupported({ attestation }));
      },
    );

    test('Shold throw type mismatch when attestation is not in enum', async () => {
      const publicKeyCredentialCreationOptions = {
        ...PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
        attestation: 'WRONG_ATTESTATION',
      };

      await expect(async () =>
        createCredentialAndVerifyRegistrationResponse({
          authenticator,
          publicKeyCredentialCreationOptions:
            publicKeyCredentialCreationOptions as PublicKeyCredentialCreationOptions,
        }),
      ).rejects.toThrowError();
    });
  });

  describe('PublicKeyCredentialCreationOptions.pubKeyCredParams', () => {
    test('Should throw type mismatch when pubKeyCredParams is empty', async () => {
      const publicKeyCredentialCreationOptions = {
        ...PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
        pubKeyCredParams: [],
      };

      await expect(async () =>
        createCredentialAndVerifyRegistrationResponse({
          authenticator,
          publicKeyCredentialCreationOptions,
        }),
      ).rejects.toThrowError();
    });

    test.each([
      {
        pubKeyCredParams: [{ type: 'WRONG_TYPE', alg: COSEKeyAlgorithm.ES256 }],
      } satisfies Partial<PublicKeyCredentialCreationOptions>,
      {
        pubKeyCredParams: [
          {
            type: PublicKeyCredentialType.PUBLIC_KEY,
            alg: -8,
          },
        ],
      } satisfies Partial<PublicKeyCredentialCreationOptions>,
      {
        pubKeyCredParams: [
          {
            type: PublicKeyCredentialType.PUBLIC_KEY,
            alg: -8,
          },
          {
            type: 'WRONG_TYPE',
            alg: COSEKeyAlgorithm.ES256,
          },
        ],
      } satisfies Partial<PublicKeyCredentialCreationOptions>,
    ])(
      'Should throw with any supported pubKeyCredParams',
      async ({ pubKeyCredParams }) => {
        const publicKeyCredentialCreationOptions = {
          ...PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
          pubKeyCredParams,
          attestation: undefined,
        };

        await expect(async () =>
          createCredentialAndVerifyRegistrationResponse({
            authenticator,
            publicKeyCredentialCreationOptions,
          }),
        ).rejects.toThrowError(new NoSupportedPubKeyCredParamFound());
      },
    );
  });

  describe('meta.userId', () => {
    test('Should throw type mismatch when userId is invalid', async () => {
      await expect(async () =>
        authenticator.createCredential({
          publicKeyCredentialCreationOptions:
            PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
          generateKeyPair: async () => ({
            COSEPublicKey: COSEPublicKey.toBuffer(),
            webAuthnCredentialKeyMetaType:
              WebAuthnCredentialKeyMetaType.KEY_VAULT,
            webAuthnCredentialKeyVaultKeyMeta: {
              keyVaultKeyId: KEY_VAULT_KEY_ID,
              keyVaultKeyName: KEY_VAULT_KEY_NAME,
              hsm: false,
            },
          }),
          signatureFactory: ({ data }) => credentialSigner.sign(data),
          meta: {
            userId: 'INVALID_USER_ID',
            origin: RP_ORIGIN,
          },
        }),
      ).to.rejects.toThrowError();
    });
  });
});

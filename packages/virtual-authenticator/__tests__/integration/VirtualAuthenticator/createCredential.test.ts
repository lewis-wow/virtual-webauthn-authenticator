import { WebAuthnCredentialKeyMetaType } from '@repo/enums';
import { COSEKey } from '@repo/keys';
import { PrismaClient } from '@repo/prisma';
import {
  CHALLENGE_BASE64URL,
  KEY_VAULT_KEY_ID,
  KEY_VAULT_KEY_NAME,
  PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
  RP_ID,
  RP_ORIGIN,
  upsertTestingUser,
  USER_ID,
} from '@repo/test-helpers';
import { bytesToUuid } from '@repo/utils';
import { PublicKeyCredentialDtoSchema } from '@repo/validation';
import {
  verifyRegistrationResponse,
  type RegistrationResponseJSON,
} from '@simplewebauthn/server';
import { afterAll, beforeAll, describe, expect, test } from 'vitest';

import { VirtualAuthenticator } from '../../../src/VirtualAuthenticator';
import { COSEPublicKey, keyPair } from '../../helpers/key';

const prisma = new PrismaClient();

const cleanup = async () => {
  await prisma.$transaction([
    prisma.user.deleteMany(),
    prisma.webAuthnCredential.deleteMany(),
    prisma.webAuthnCredentialKeyVaultKeyMeta.deleteMany(),
  ]);
};

describe('VirtualAuthenticator.createCredential()', () => {
  let authenticator: VirtualAuthenticator;

  beforeAll(async () => {
    await cleanup();

    // Ensure the standard testing user exists in the database.
    await upsertTestingUser({ prisma });

    // Initialize the VirtualAuthenticator instance, passing in the Prisma client
    // for database interactions.
    authenticator = new VirtualAuthenticator({ prisma });
  });

  afterAll(async () => {
    await cleanup();
  });

  test('createCredential()', async () => {
    // Simulate the full WebAuthn registration ceremony.
    // This creates a new public key credential (passkey) using the
    // specified options, public key, and key vault metadata.
    const publicKeyCredential = await authenticator.createCredential({
      publicKeyCredentialCreationOptions:
        PUBLIC_KEY_CREDENTIAL_CREATION_OPTIONS,
      generateKeyPair: async () => ({
        COSEPublicKey: COSEPublicKey.toBuffer(),
        meta: {
          webAuthnCredentialKeyMetaType:
            WebAuthnCredentialKeyMetaType.KEY_VAULT,
          webAuthnCredentialKeyVaultKeyMeta: {
            keyVaultKeyId: KEY_VAULT_KEY_ID,
            keyVaultKeyName: KEY_VAULT_KEY_NAME,
            hsm: false,
          },
        },
      }),
      meta: {
        user: {
          id: USER_ID,
        },
        origin: RP_ORIGIN,
      },
    });

    // Verify the registration response generated by the authenticator.
    // This confirms the credential was created correctly according to
    // WebAuthn standards and our server's expectations (challenge, RP ID, etc.).
    const registrationVerification = await verifyRegistrationResponse({
      response: PublicKeyCredentialDtoSchema.encode(
        publicKeyCredential,
      ) as RegistrationResponseJSON,
      expectedChallenge: CHALLENGE_BASE64URL,
      expectedOrigin: RP_ORIGIN,
      expectedRPID: RP_ID,
      requireUserVerification: true, // Authenticator does perform UV
      requireUserPresence: false, // Authenticator does NOT perform UP
    });

    const webAuthnCredentialId = bytesToUuid(publicKeyCredential.rawId);

    expect(registrationVerification.verified).toBe(true);

    expect(registrationVerification.registrationInfo?.credential.counter).toBe(
      0,
    );

    const jwk = COSEKey.fromBuffer(
      registrationVerification.registrationInfo!.credential.publicKey,
    ).toJwk();

    expect(jwk).toMatchObject(keyPair.publicKey.export({ format: 'jwk' }));

    const webAuthnCredential = await prisma.webAuthnCredential.findUnique({
      where: {
        id: webAuthnCredentialId,
      },
    });

    expect(webAuthnCredential).toMatchObject({
      id: webAuthnCredentialId,
    });
  });
});

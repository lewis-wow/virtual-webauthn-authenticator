import { USER_ID } from '../../../../auth/__tests__/helpers';

import { UUIDMapper } from '@repo/core/mappers';
import { toB64 } from '@repo/utils';
import {
  type RegistrationResponseJSON,
  verifyRegistrationResponse,
} from '@simplewebauthn/server';
import { expect } from 'vitest';

import { VirtualAuthenticatorAgent } from '../../../src/agent/VirtualAuthenticatorAgent';
import {
  UserPresenceRequiredAgentException,
  type UserPresenceRequiredAgentExceptionData,
} from '../../../src/agent/exceptions/UserPresenceRequiredAgentException';
import {
  UserVerificationRequiredAgentException,
  type UserVerificationRequiredAgentExceptionData,
} from '../../../src/agent/exceptions/UserVerificationRequiredAgentException';
import type { RegistrationStateWithTokenAgent } from '../../../src/agent/state/RegistrationStateAgentSchema';
import { decodeAttestationObject } from '../../../src/cbor/decodeAttestationObject';
import { parseAuthenticatorData } from '../../../src/cbor/parseAuthenticatorData';
import { PublicKeyCredentialDtoSchema } from '../../../src/dto/spec/PublicKeyCredentialDtoSchema';
import { UserVerification } from '../../../src/enums/UserVerification';
import { StateManager } from '../../../src/state/StateManager';
import { StateType } from '../../../src/state/StateType';
import type { AuthenticatorAgentMetaArgs } from '../../../src/validation/authenticatorAgent/AuthenticatorAgentMetaArgsSchema';
import type { PublicKeyCredentialCreationOptions } from '../../../src/validation/spec/PublicKeyCredentialCreationOptionsSchema';
import type { PublicKeyCredential } from '../../../src/validation/spec/PublicKeyCredentialSchema';
import { RP_ORIGIN } from '../../helpers/consts';

export type PerformPublicKeyCredentialRegistrationAndVerifyArgs = {
  stateManager: StateManager;
  agent: VirtualAuthenticatorAgent;
  publicKeyCredentialCreationOptions: PublicKeyCredentialCreationOptions;
  meta?: Partial<AuthenticatorAgentMetaArgs>;
  state?: RegistrationStateWithTokenAgent;
};

export const performPublicKeyCredentialRegistrationAndVerify = async (
  opts: PerformPublicKeyCredentialRegistrationAndVerifyArgs,
) => {
  const {
    agent,
    publicKeyCredentialCreationOptions,
    meta: metaOptions = {},
    state,
  } = opts;

  const meta: AuthenticatorAgentMetaArgs = {
    userId: USER_ID,
    apiKeyId: null,
    origin: RP_ORIGIN,

    userPresenceEnabled: true,
    userVerificationEnabled: true,
    ...metaOptions,
  };

  const expectedRPID =
    publicKeyCredentialCreationOptions?.rp?.id ?? new URL(meta.origin).hostname;

  // Simulate the full WebAuthn registration ceremony.
  // This creates a new public key credential (passkey) using the
  // specified options, public key, and key vault metadata.
  // Simulate the full WebAuthn registration ceremony.
  let publicKeyCredential: PublicKeyCredential | undefined;
  let currentState = state;
  let attempts = 0;
  const MAX_ATTEMPTS = 5;

  while (!publicKeyCredential && attempts < MAX_ATTEMPTS) {
    attempts++;
    try {
      publicKeyCredential = await agent.createCredential({
        origin: meta.origin,
        options: {
          publicKey: publicKeyCredentialCreationOptions,
        },
        sameOriginWithAncestors: true,

        // Internal options
        meta,
        state: currentState,
      });
    } catch (error) {
      if (error instanceof UserPresenceRequiredAgentException) {
        const data =
          error.data as unknown as UserPresenceRequiredAgentExceptionData;
        const decodedState = await opts.stateManager.validateToken(data.state);

        currentState = {
          type: StateType.REGISTRATION,
          optionsHash: decodedState.optionsHash,
          ...decodedState.current,
          up: true,
        } as RegistrationStateWithTokenAgent;
      } else if (error instanceof UserVerificationRequiredAgentException) {
        const data =
          error.data as unknown as UserVerificationRequiredAgentExceptionData;
        const decodedState = await opts.stateManager.validateToken(data.state);

        currentState = {
          type: StateType.REGISTRATION,
          optionsHash: decodedState.optionsHash,
          ...decodedState.current,
          uv: true,
          up: true, // UV implies UP usually
        } as RegistrationStateWithTokenAgent;
      } else {
        throw error;
      }
    }
  }

  if (!publicKeyCredential) {
    throw new Error('Failed to create credential after maximum attempts');
  }

  // Verify the registration response generated by the authenticator.
  // This confirms the credential was created correctly according to
  // WebAuthn standards and our server's expectations (challenge, RP ID, etc.).
  const registrationVerification = await verifyRegistrationResponse({
    response: PublicKeyCredentialDtoSchema.encode(
      publicKeyCredential,
    ) as RegistrationResponseJSON,
    expectedChallenge: toB64(publicKeyCredentialCreationOptions.challenge),
    expectedOrigin: meta.origin,
    expectedRPID,
    requireUserVerification:
      publicKeyCredentialCreationOptions.authenticatorSelection
        ?.userVerification === UserVerification.REQUIRED,
    requireUserPresence: true,
  });

  expect(registrationVerification.verified).toBe(true);

  const attestationObjectMap = decodeAttestationObject(
    registrationVerification.registrationInfo!.attestationObject,
  );

  const authData = attestationObjectMap.get('authData');

  const parsedAuthenticatorData = parseAuthenticatorData(authData);

  expect(parsedAuthenticatorData.extensionsData).toBe(undefined);

  // New credential counter should be always 0
  expect(parsedAuthenticatorData.counter).toBe(0);

  expect(parsedAuthenticatorData.flags.up).toBe(true);
  expect(parsedAuthenticatorData.flags.be).toBe(true);
  expect(parsedAuthenticatorData.flags.bs).toBe(true);

  expect(registrationVerification.registrationInfo!.credential).toBeDefined();

  const credentialUuid = UUIDMapper.bytesToUUID(publicKeyCredential.rawId);

  return {
    webAuthnCredential: registrationVerification.registrationInfo!.credential,
    publicKeyCredential,
    credentialUuid,
    registrationVerification,
    parsedAuthenticatorData,
    attestationObjectMap,
  };
};
